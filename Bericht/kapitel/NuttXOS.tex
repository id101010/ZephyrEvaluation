 % !TeX encoding = ISO-8859-1
 \chapter{NuttX Real-Overview}
 \label{chap:overview}
 
 \section{Übersicht über NuttX Real}
 
 
 NuttX ist ein Echtzeitbetriebssystem (RTOS) mit einem Schwerpunkt auf Normenkonformität und geringem Platzbedarf. Skalierbar von 8-Bit- bis 32-Bit-Mikrocontroller-Umgebungen sind die primären Normen in NuttX die Posix- und ANSI-Standards. Zusätzliche Standard-APIs von Unix und anderen gängigen RTOS, wie VxWorks, werden für die Funktionalität, die unter diesen Standards nicht verfügbar ist, oder für Funktionalitäten, die für tief eingebettete Umgebungen wie zum Beispiel ''fork'' nicht geeignet sind, übernommen.
 NuttX wurde zuerst 2007 von Gregory Nutt unter der permissiven BSD Lizenz veröffentlicht.
 
 

 NuttX, wie bei vielen RTOS, ist eine Sammlung von verschiedenen Funktionen gebündelt als Bibliothek. Es wird nicht ausgeführt ausser wenn entweder:
 
  \vspace{5mm}
  \begin{itemize}
  	\item Die Anwendung den NuttX-Bibliothekscode aufruft
  	\item Ein Interrupt auftritt

  \end{itemize}
  \vspace{5mm}
  
  
 NuttX implementieren ein virtuelles Dateisystem ''VFS'', das verwendet werden kann, um mit einer Anzahl von Verschiedene  Entities  Schnittstellen   über die standardmäßigen open(), close(), read(), write(), etc. zu kommunizieren. 
 
 Wie andere VFSs unterstützt das NuttX VFS Dateisystem-Mountpunkte, Dateien, Verzeichnisse, Gerätetreiber usw. Auch wie bei anderen VFSs unterstützt das  NuttX-Dateisystem psuedo-Dateisysteme, also Dateisysteme, die als normale Medien erscheinen, aber wirklich unter programmatischer Kontrolle präsentiert werden. 
 Das NuttX-Root-Dateisystem ist immer ein Pseudo-Dateisystem. Das ist genau das Gegenteil von Linux. Mit Linux muss das Root-Dateisystem immer ein physikalisches Block-Device sein, wenn auch nur ein initrd-RAM-Datenträger. Bei NuttX ist das Root-Dateisystem immer ein Pseudofile System, das keinen zugrunde liegenden Blocktreiber oder physikalisches Gerät benötigt. Dann können Sie montieren
 Realen Dateisystem im Pseudo-Dateisystem. Diese Anordnung macht das Leben viel einfacher für die kleine eingebettete Welt. NuttX interagiert mit Geräten über Gerätetreiber - das heißt über Software, die Hardware steuert und
    
    
 NuttX unterstützt auch POSIX pthreads und die NuttX pthreads unterstützen auch dieses Verhalten. Das heißt, die NuttX POSIX pthreads teilen sich auch die Ressourcen der übergeordneten Aufgabe. Allerdings, da NuttX nicht
 Support-Prozess-Adresse Umgebungen, ist der Unterschied nicht so auffällig. Wenn eine Task einen pthread erzeugt, Die neu erstellen pthread teilen die Umgebungsvariablen, Dateideskriptoren, Sockets und Streams von Die übergeordnete Aufgabe. Hinweis: Diese Task-Ressourcen werden als Referenz gezählt und bleiben so lange bestehen, wie Thread in der Task-Gruppe ist immer noch aktiv:
    
 \vspace{5mm}
 \begin{itemize}
  \item Umgebungsvariablen, ist die Sammlung von variablen Zuordnungen: ''VARIABLE = VALUE'' 	
  \item Ein Dateideskriptor ist eine aufgabenbezogene Zahl, die eine offene Ressource darstellt, Datei oder einen Gerätetreiber
  \item Ein Socket-Deskriptor ist wie ein Dateideskriptor, aber die offene Ressource ist in diesem Fall ein Netzwerk-Buchse
  \item Streams wickeln Dateideskriptoren oder Sockets ein und bieten einen neuen Satz von Schnittstellenfunktionen für den Umgang mit der Standard-C Funktionen an.  	
 \end{itemize}
   
 \vspace{5mm}
 
 \section{Ziele}
 
 \vspace{5mm}
 
 Es gibt einige RTOS-Funktionen, die durch interne Threads implementiert werden.
 Um ein Echtzeit-OS zu sein, muss ein RTOS ''SCHED FIFO'' unterstützen. Das heißt, strenge Priorität Scheduling. Eines Scheduler: Diese Logik, die steuert, wenn Tasks oder Threads ausgeführt werden. Der Scheduler bestimmt, was eine Task oder ein Thread ist. In NuttX ist ein Thread eine beliebige steuerbare Sequenz der Befehlsausführung, die einen eigenen Stack hat. Jeder Aufgabe wird durch eine Datenstruktur dargestellt, die als Task-Steuerblock oder TCB bezeichnet wird. Diese TCBs werden in Listen aufbewahrt. Der Zustand einer Task wird im Feld ''Task State'' angezeigt. Die meisten dieser Listen sind priorisier. So dass eine gemeinsame Listenhandhabungslogik verwendet werden kann. Threads, die vom Betriebssystem verwaltet werden. Ein Prozess ist mehr als ein Thread, wie wir bisher diskutiert haben. Ein Prozess ist eine geschützte Umgebung, die einen oder mehrere Threads hostet. Unter Umgebung verstehen wir den Satz von Ressourcen von der OS.

 Um den Adressraum des Prozesses zu implementieren, muss die CPU eine Speicherverwaltungseinheit unterstützen MMU. Allerdings wurde NuttX entworfen auch mit beschränkten Ressourcen zufunktionieren. Diese CPUs haben selten eine MMU und können daher Prozesse niemals unterstützen. So unterstützt NuttX keine Prozesse.NuttX arbeitet nur in einem flachen Adressraum, um Befehls- und Datencaches zu steuern und geschützte Speicherbereiche zu unterstützen. Die dem TCB am Anfang der readytorun-Liste zugeordnet ist. NuttX unterstützt eine weitere Echtzeit-Planungsrichtlinie: ''SCHED RR''. Die RR steht für Roundrobin
 Und dies wird manchmal als Round-Robin-Scheduling bezeichnet. In diesem Fall unterstützt NuttX das Timelicing. Eine Aufgabe mit ''SCHED RR'' Scheduling-Richtlinie ausgeführt wird, dann, wenn jedes timeslice vergeht, wird es aufgeben
 Die CPU auf die nächste Task, die die gleiche Priorität hat. Jede Aufgabe wird nicht nur durch eine TCB, sondern auch durch eine numerische Task-ID dargestellt. Bei einem TCB kann das RTOS die Task-ID finden. Sie sind also funktional gleichwertig. Nur die Task-ID wird jedoch an den RTOS / Application Interfaces freigelegt.

 \vspace{5mm} 

 \section{Aubau}
 \vspace{5mm}
 

  Auf der höchsten Ebene kann die NuttX-Initialisierungssequenz in drei Phasen dargestellt werden:
  
   \vspace{5mm}
   \begin{itemize}
   	\item Die hardware-spezifische Einschalt-Reset-Initialisierung	
   	\item NuttX RTOS Initialisierung
   	\item Anwendungsinitialisierung
  	
   \end{itemize}
   \vspace{5mm}

  Diese Initialisierungssequenz ist wirklich ganz einfach, weil das System i Single-Thread-Modus läuft. Bis der Punkt beginnt, der die Anwendung startet. Das bedeutet, dass die Initialisierungssequenz gerade ist Einfache, geradlinige Funktionsaufrufe. Kurz vor dem Starten der Anwendung geht das System in den Multi-Thread-Modus, und die Dinge können mehr bekommen
  Komplex. Die Software beginnt mit der Ausführung, wenn der Prozessor zurückgesetzt wird. In der Regel beim Einschalten, aber alle Rückstellungen sind
  Grundsätzlich die gleichen, wo sie auftreten, weil der Power-on, drücken Sie die Reset-Taste, oder auf einem Watchdog Timer-Ablauf. Die Software, die ausgeführt wird, wenn der Prozessor zurückgesetzt wird, ist für die jeweilige CPU eindeutig
  Architektur und ist kein gemeinsamer Bestandteil von NuttX. Die Art der Dinge, die von der Architektur-spezifische Reset-Handling beinhaltet:
  
     \vspace{5mm}
     \begin{itemize}
     	\item Setzen des Prozessors in seinen Betriebszustand. Dies kann Dinge wie Einstellung wie, CPU-Modi und Initialisierung von Co-Prozessoren	
     	\item Einstellen der Taktung, so dass die Software und Peripherie wie erwartet funktionieren und einrichten des C-Stack-Zeigers
     	\item Speicher initialisieren und Starten von NuttX	
     \end{itemize}
     \vspace{5mm}

 \vspace{5mm}
 \section{Unterstütztung}
 
 Momentan unterstützt der NuttX-Kernel gemäss Angaben auf der Projektseite \cite{ZephyrProjectDocumentation} Prozessoren der Architekturen ARM. Folgende Hardware wurde zum Zeitpunkt unserer Projektarbeit unterstütz:
 
 \vspace{5mm}
 
 \begin{center}
 	\begin{tabular}{ | l |}
 		\hline
 		\textbf{Hersteller} 				\\ \hline
 		ARM7TDMI 							\\ \hline
 		ARM920T 							\\ \hline
 		ARM926EJS 							\\ \hline
 		ARM Cortex-A5						\\ \hline	
 		ARM Cortex-A8						\\ \hline
 		ARM Cortex-R4/R4F					\\ \hline
 		ARM Cortex-M0 						\\ \hline
 		ARM Cortex-M3 						\\ \hline
 		ARM Cortex-M4 						\\ \hline
 		ARM Cortex-M7 						\\ \hline
 		Atmel 8-bit AVR (AT90USB, ATmega)	\\ \hline
 		AVR32								\\ \hline
 		Freescale M68HCS12					\\ \hline
 		Intel X86							\\ \hline
 		MicroChip PIC32MX (MIPS32 24Kc)		\\ \hline
 		MicroChip PIC32MZ (MIPS32 M14k)		\\ \hline
 		Renesas/Hitachi SuperH				\\ \hline
	 	Renesas M16C/26						\\ \hline
 		Zilog Z16F ZNeo						\\ \hline
 		Zilog eZ80 Acclaim					\\ \hline
 		Zilog Z8Encore						\\ \hline
 		Zilog Z80 							\\ \hline
 		\hline
 	\end{tabular}
 \end{center}
 
 \vspace{15mm}
 
  Zur Kommunikation unterstützt das NuttX-Betreibssystem eine Vielzahl an Kommunitations-Protokolle. Da der Fokus auf das Internet der Dinge gelegt wurde, wurden auch die entsprechenden Protokolle zuerst implementiert. 
  
  Folgende Tabelle zeigt die Kommunikationsmöglichkeiten sowohl die vom Betriebssystem unterstützte Hardwarekomponenten wie auch die unterstützten Protokolle:
  
  \vspace{5mm}
  
  \begin{center}
  	\begin{tabular}{ | l | l |}
  		\hline
  		\textbf{Protokoll} 		& \textbf{Hardwarekomponente} \\ \hline
  		DHCP 						& ADC 		\\ \hline
  		HTTP						& CAN		\\ \hline
	  	ICMP /  ICMPv6 / ICMPv2		& GPIO		\\ \hline
  		IPv4 / IPv6					& I2C	 	\\ \hline
  		TCP	/ IP					& PWM			\\ \hline
  		NFR							& SPI			\\ \hline
  		UDP / APR					& UART			\\ \hline
  		6LoWPAN 					& USB			\\ \hline
  		\hline
  	\end{tabular}
  \end{center}
  

 

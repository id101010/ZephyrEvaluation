% !TeX encoding = ISO-8859-1
\chapter{Applikationsentwicklung mit Zephyr}
\label{chap:zephyrdevel}

\section{Übersicht}

Das Buildsystem des Zephyr-Kernels basiert auf Kbuild. Kbuild ist das System, welches für den Linux Kernel entwickelt wurde.

Um eine Applikation zu erstellen, ist ein Konfigurationsfile für den Kernel notwendig. Das Buildsystem kompiliert dann sowohl den Kernel als auch die Applikation und erstellt ein einziges Binary daraus.

Im folgenden wird unterschieden zwischen dem Kernel-Ordner und dem Applikations-Ordner. Der Kernel-Ordner enthält den vollständigen Quellcode des Kernels, die Standardkonfiguration und die Build Definitionen für den Kernel. Der Applikationsordner enthält den ganzen Quellcode und spezifische Konfigurationen für den Kernel. Im Quellcode der Applikation wird lediglich auf den Kernel gelinkt. Wenn keine neuen Treiber entwickelt werden sollen, beschränkt sich die Applikationsentwicklung ausschliesslich auf die Konfigurationen und den Quellcode im Applikationsverzeichnis. Der Kernel selbst muss nicht verändert werden, da dies vom Buildsystem erledigt wird.

\section{Applikationsstruktur}

Das Minimum einer Applikationsstruktur sieht folgendermassen aus:

\begin{itemize}
	\item \textbf{Quelltext der Applikation} Applikationen werden typischerweise in C oder Assembler geschrieben und liegen im Ordner src.

	
	\item \textbf{Kernel Konfigurationsfiles} Eine Zephyrapplikation stellt dem Buildsystem ein Konfigurationsfile *.conf zur Verfügung. Fehlt diese Datei, wird die Standardkonfiguration verwendet.

	
	\item \textbf{Makefile} Diese Datei teilt dem Buildsystem lediglich mit, wo die oben genannten Dateien zu finden sind und um was für ein Board es sich beim Target handelt. Es handelt sich dabei nicht um ein Makefile im klassischen Sinne.
\end{itemize}

Wurde die Applikation nach obigem Standard definiert, kann sie mit einem einzigen Aufruf vom \textbf{make} gebaut werden. Das Kompilat findet sich in einem eigens dafür erstellten Unterordner namens \textbf{outdir/BOARD}. Vom Buildsystem werden folgende Dateien generiert:

\begin{itemize}
	\item Das \textbf{.config} File enthält die Einstellungen, welche vom Buildsystem für das Erstellen der Applikation benutzt wurden.
	\item Object-Files \textbf{.o und .a}, welche Kompilat aus Kernel und Applikation enthalten.
	\item Das \textbf{zephyr.elf} Binary, welches Kernel- und Applikationscode in sich vereint.
\end{itemize}  

\vspace{10mm}

\section{Bedienung des Build-Systems}

Die Verwendung des Buildsystems gestaltet sich denkbar einfach. Es muss lediglich das zentrale Makefile ins Projektmakefile inkludiert werden, das Programm Make erledigt dann den Rest. Folgende Zeile muss dem Makefile hinzugefügt werden:

\begin{lstlisting}[style=BashInputStyle]
$ include $(ZEPHYR_BASE)/Makefile.inc
\end{lstlisting}

Weiter erwartet das Buildsystem einige Umgebungsvariablen, die jedoch im Normalfall automatisch gesetzt werden. Der Vollständigkeit halber folgt im Anschluss eine Liste.

\begin{itemize}
	\item \textbf{ZEPHY-BASE} Hier steht der Pfad zum Ordner, welcher den vollständigen Kernel Sourcecode enthält. Diese Variable wird über das Sourcen des zephyr-env.sh Skriptes gesetzt, wie in Kapitel 2.5.3 beschrieben.
	\item \textbf{PROJECT-BASE} Hier steht der Pfad zum Applikationsordner. Diese Variable wird durch das Makefile gesetzt.
	\item \textbf{SOURCE-DIR} Hier steht der Pfad zum Quelltext der Applikation, per Standard zeigt diese Variable auf den Unterordner src.
	\item \textbf{BOARD} Diese Variable gibt an für welches Board die Applikation kompiliert werden soll.
	\item \textbf{CONF-FILE} Diese Variable gibt an welche speziellen Kernelkonfigurationen vorgenommen werden sollen.
	\item \textbf{O} Hier befindet sich der Ordner in welchem sich das kompilierte Binary befinden wird. Standardmässig wird dies der Unterordner outdir sein.
\end{itemize}  

Applikationsspezifischer Quelltext wird üblicherweise im src Ordner abgelegt. Selbstverständlich kann der Code in diesem Ordner übersichtlich in Unterordnern modularisiert werden. Wichtig ist hierbei, dass jeder Unterordner ein Makefile enthält! Dieses Makefile ist wie folgt zu erstellen:

\begin{itemize}
	\item In jedem Unterordner muss ein Makefile erstellt werden, welches alle Dateien für Kbuild referenziert.
	\item Um Dateien zu referenzieren ist die folgende Syntax zu verwenden:
	\begin{lstlisting}[style=BashInputStyle]
	obj-y += file1.o file2.o
	\end{lstlisting}
	\item Um Unterordner zu referenzieren ist die folgende Syntax zu verwenden:
	\begin{lstlisting}[style=BashInputStyle]
 	obj-y += directory_name/**
	\end{lstlisting}
\end{itemize}


\section{Konfiguration der Kernelparameter}

Der Kernel, welcher für und mit der Applikation kompiliert wird, kann mittels Buildsystem speziell für die Ansprüche der Applikation angepasst werden. Um dies zu tun, gibt es mehrere Möglichkeiten. Die dazu anzupassenden Konfigurationsdateien sind im Folgenden in hierarchischer Weise aufgelistet. Das bedeutet, dass die erste Konfiguration der Liste alle anderen überschreiben wird.

\begin{enumerate}
	\item Konfigurationsdatei der Applikation anpassen (.config)
	\item Spezifische Konfiguration des Boards in der SDK anpassen (.defconfig)
	\item Kernelkonfiguration direkt anpassen (Kconfig Dateien)
\end{enumerate}

Eine Anpassung der Config des Kernels macht nur für sehr spezifische Applikationen wirklich Sinn. Auf diese Option sollte nur zu Optimierungszwecken zurückgegriffen werden. Eine sehr ausführliche Liste mit allen Konfigurationen finden sich im Kernel Primer Guide auf der Homepage des Zephyr Projektests. Da dies den Rahmen der Dokumentation sprengen würde, wird an dieser Stelle auf eine ausführliche Beschreibung verzichtet. Nachfolgend wird auf die restlichen Möglichkeiten und deren Einsatzzweck eingegangen.

\subsection{Boardkonfiguration}

Die Konfigurationen des Kernels für die unterstützten Boards befinden sich in der SDK unter folgendem Link:

\begin{lstlisting}[style=BashInputStyle]
$ZEPHYR_BASE/boards/ARCHITECTURE/BOARD/BOARD_defconfig
\end{lstlisting}

Die Boardkonfiguration enthält alle Kernelkonfigurationen, um die Hardwarekomponenten des Entwicklungskits zu betreiben. Wenn die bereits gesetzten Werte der Boardkonfiguration ausreichend sind, kann auf eine weiterführende Konfiguration verzichtet werden. Sollen aber beispielsweise Debugfunktionen, wie die serielle Printfunktion printk, zur Verfügung stehen, lässt sich das über ein einfaches Bearbeiten der entsprechenden Konfiguration des Boards erreichen. Wichtig ist dabei die Syntax einzuhalten:

\begin{itemize}
	\item Jede Konfiguration muss auf einer eigenen Zeile stehen.
	\item Konfigurationen beginnen immer mit dem Präfix CONFIG
	\item Konfigurationen dürfen keine Leerzeichen enthalten, auch nicht vor oder nach dem Gleichheitszeichen!
	\item Alle mit einer Raute beginnenden Zeilen sind Kommentar. 
\end{itemize} 

Folgende Zeile stellt allen Applikationen, welche mit der angepassten Boardkonfiguration kompiliert werden die serielle Ausgabe zur Verfügung:

\begin{lstlisting}[style=BashInputStyle]
# Enable printk for debugging
CONFIG_PRINTK=y
\end{lstlisting}

\subsection{Applikationsspezifische Konfiguration}

Diese Konfigurationsmethode kann verwendet werden, um alle Standardkonfigurationen permanent zu überschreiben. Sie baut daher auch auf einem graphischen ncurses-Menu auf, wie man sich es von der Kompilierung des Linuxkernels gewohnt ist.

Das Menu kann folgendermassen via make aufgerufen werden:

\begin{lstlisting}[style=BashInputStyle]
make [BOARD=<type>] menuconfig
\end{lstlisting}

Mit dem Boardparameter kann auch noch eine spezifische Boardkonfiguration mitberücksichtigt werden.
Sind alle gewünschten Einstellungen getätigt, kann die Konfiguration unter dem bereits gesetzten Namen abgespeichert werden. Im Applikationsverzeichnis wird daraufhin ein Ordner namens outdir erstellt, welcher die eben erstellte Customconfig enthält. Wichtig ist hier, dass sich im outdir nur eine .config Datei befinden darf. Wenn mit unterschiedlichen Konfigurationen experimentiert wird, sollten die restlichen Dateien in einem separaten Ordner abgespeichert werden. Selbstverständlich werden Dateien mit einer Punktierung im Namen von sämtlichen Linuxsystemen als versteckte Datei behandelt.

\newpage

\section{Debugging mit GDB}

Der folgende Abschnitt beschreibt das Debugging von Zephyr-Applikationen im Allgemeinen. Da die Toolchain von Nordic nicht Open-Source ist, wird sie vom Zephyr-Makefile nicht offiziell unterstützt. Für das Debugging von Applikationen auf dem nrf52dk sei an dieser Stelle auf das Kapitel 9 verwiesen.

Nachfolgende Grafik zeigt den Aufbau einer Debugging-Kette wie sie für moderne Mikrocontrollersysteme oft verwendet wird.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.7\linewidth]{bilder/gdb-debugging-chain.png}
	\caption{GDB Debugging Chain}
	\label{fig:debuggingtoolchain}
\end{figure}

Die Kette setzt sich zusammen aus dem \ac{GDB}, einem GDB Server, der Schnittstelle aufs Board und natürlich dem Board selbst.

Der \ac{GDB} ist im Internet als freie Software verfügbar und auf den unterschiedlichsten Architekturen lauffähig. Im Bild ist er als GDB-Client gekennzeichnet. 
Der GDB-Server ist ein Stück Software, welche über einen TCP-Socket dem GDB-Client ein Interface zur Verfügung stellt. Über dieses Interface lässt sich das Board über GDB steuern. Es können Breakpoints gesetzt und aktuelle Registerwerte ausgelesen werden.
Die Schnittstelle zwischen Board und GDB-Server ist in den meisten Fällen via \ac{JTAG} oder \ac{SWD} möglich. Auf Entwicklungsboards ist die Debugging-Hardware meist direkt auf Boardlevel implementiert.

Die Firma Nordic setzt beispielsweise bei ihren Boards J-Link von SEGGER ein. Dazu gehört ein GDB-Server und ein J-Link Gerät. Beim nrf52dk ist J-Link bereits auf dem Board verbaut und via USB ansprechbar.


\section{nrf52dk-zephyr-tool.sh}

Das Makefile der Zephyr-Build-Tools erlaubt es mittels \textbf{make flash} Software auf Boards direkt herunterzuladen. Jedoch muss beim nrf52 Development-Kit auf proprietäre Software von SEGGER zurückgegriffen werden. Da diese Software nicht quelloffen ist, kann sie nicht mit den Build-Tools ausgeliefert werden.
Um die Entwicklung von Zephyrapplikationen dennoch zu vereinfachen, ist im Rahmen der Projektarbeit ein kleines Shellskript entstanden, welches die grundlegenden Operationen wie das Erstellen eines Projektes mit Minimalkonfiguration, das Kompilieren einer Applikation oder das Herunterladen eines Binarys auf das nrf52 Development-Kit erlaubt. Die Bedienung des Shellskripts hält sich an die gängigen Unix Standards. Mehr dazu ist im Kapitel 9 zu finden.
